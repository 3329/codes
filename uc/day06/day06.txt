回顾:
	1.通用选项
	2.预处理与相关指令
	3.内置宏 __cplusplus
	4.静态库
一.动态库
	1.动态库的编译与连接
			a.编译成目标文件
					可选选项-fpic   
			b.连接成动态库
			(共享库)
					选项-shared
		注意:共享库的扩展名.so(shared objective)
				 库名称的命名规则：lib库名.so		
		
		案例：
			写代码:输入整数，判定是否素数。
						整数的输入，素数判定封装成动态库.
			动态库操作:
					nm 查看目标文件,执行文件的函数符号			
			
	2.使用动态库
			a.在连接的时候，需要指定动态库
			b.执行程序加载动态库
						程序执行的同时，动态库会加载，并且通过映射，把动态库映射到程序的内存空间。
						
						动态库的加载过程：系统首先找到动态库.
								然后加载，最后映射到执行程序。
						系统查找动态库的搜索机制：
								首先在/lib下查找
								然后在/usr/lib下查找
								最后在LD_LIBRARY_PATH环境变量指定的路径中查找。		
						实际系统查找动态库：在缓冲列表中搜索。
								/lib
								/usr/lib
								LD_LIBRARY_PATH中的路径被缓冲到系统内存中。
								
			连接执行文件指定动态库的作用：
					告诉连接器函数的偏移地址及其存在。
					不会把动态库连接到执行文件。
			工具：
					ldd 查看执行程序（包含动态库）执行需要加载的动态库		
					ldconfig -v 刷新动态库查找清单缓冲
								影响到一个缓冲文件ldconfig.cache
								
					删除执行文件多余信息 
						strip  执行文件
						
									
		今后的主要任务：
					libc.so
								
	3.动态库的运行时加载
			3.1.动态库的加载
            void *dlopen(const char*filename,int flag);
	            返回：打开的动态库在内存中的地址。
				参数1：动态库文件名。（支持相对路径）
				参数2：打开动态库方式
								RTLD_LAZY
								RTLD_NOW					
			3.2.在动态库中查找函数符号
            void *dlsym(void *ptr,const char *sym);
            	返回：找到的函数指针
				参数1：打开的动态库地址
				参数2：函数名
							
			3.3.卸载动态库
			dlclose(void *ptr);
			
		      上面三个步骤使用三个函数
				dlopen
				dlsym
				dlclose
		      而且这三个函数已经封装成动态库
				libdl.so		
				
二.函数指针：
		1.函数类型-函数原型
			返回类型 (*)	(参数列表);			
			
		2.定义函数指针
			返回类型 (*函数指针名)	(参数列表);
		
		3.函数类型转换
			(返回类型 (*)	(参数列表))指针;
		
		
		4.函数指针赋值
			函数指针名=函数名;
			函数指针名=指针;
			
		5.把函数类型重定义		
			typedef 返回类型 (*函数类型名)	(参数列表);	
		6.函数的调用。
			__attribute((stdcall))
			__attribute((fastcall))
			__attribute((cdecl))
			
			thiscall C++独有(关键字不存在)
			
三.IO与文件目录管理
	1.文件描述符号
		每个程序运行中都会打开文件。
		文件的打开由系统管理。
		一般用户不允许直接操作文件。
		文件由系统打开，在系统内存空间（Kernel空间）建立文件缓冲，该内存空间用户不能直接访问。
		
		所有访问通过ID。用户要通过ID与专门的函数访问文件对应内核空间。
		
		每个程序在进程目录下
				/proc/$pid/fd/文件描述符号列表
		每个程序默认打开3个文件.
				0  ：对应字符设备文件：标准输入设备文件
				1   : 对应字符设备文件：标准输出设备文件
				2	: 对应字符设备文件：标准错误输出设备文件
      试验：
		观察0 1 2 这三个文件描述符号对应的打开设备文件
		0 1 2 读写执行权限对应到/dev/pts/1设备文件
      总结：
		1.文件描述符号是文件在程序内存中的表示
		2.程序中访问文件有两种方式：
					通过文件名访问
					通过文件描述符号访问。(推荐)	
								
	2.文件读写
		文件描述符号的操作：读read/写write
		
		函数说明：
		ssize_t write(int fd,  //文件描述符号
					const void *buf, //写往文件数据地址
					size_t len)   //写往文件的数据长度
		
		返回：
				>=0 :实际写成功的数据长度
				=-1 :写数据失败
	      案例：
				使用write函数向1写数据.
						a.字符串
						b.整数
						c.浮点数
						d.字符
		结论：
				write按照二进制方式输出。
				当使用write写的时候,描述符号关闭，则write返回-1.
		问题：
				文本/二进制的区别
				
					  tom      123
             二进制			't''o''m'  123  	
            文本				't''o''m'  '1''2''3'
		
		read函数的说明。
		ssize_t read(
					int fd,  //文件描述符号
					void *buffer,//接收读取数据的缓冲
					size_t count)	//接收缓冲的大小	
		返回：
				>0:返回实际读取的数据长度
				=0:读到文件结束符号
					（文件：文件尾巴）  
					（终端：ctrl+d）
				-1:读取错误
	3.打开关闭文件(文件的权限与设置位)
		函数说明
			int open(
					const char *filename,//打开的文件名
					int flags,//打开的方式
					mode_t mode);//只对创建文件有效，
											//对打开文件无效
											//指定创建文件的权限.
			
			打开的方式：
						必须方式:
								O_RDONLY | O_WRONLY | O_RDWR
						创建
								O_CREAT  
											 O_EXCL	 //文件已经存在，返回错误
						打开
								什么都不需要
						辅助
								O_APPEND  追加(对O_CREAT无意义)
								O_TRUNC	清空(对O_CREAT无意义)
								
						其他方式		
			总结：
					打开文件
					 	O_RDWR
					 	O_RDWR |O_APPEND
					 	O_RDWR |O_TRUNC
					 	
					创建文件
						O_RDWR |O_CREAT
						O_RDWR |O_CREAT |O_EXCL
			
			权限：
					0777: 绝对模式（推荐）
								宏模式					
			
			返回：
					>=0:打开的文件描述符号
					=-1：创建或者打开失败 
						失败原因:errno
			
			int close(int fd)//被关闭的文件描述符号
					成功返回0，失败返回-1
	
	案例：
			创建一个文件.
			写入如下记录
					tom  			18  88.00  m
					rose 			19  100.00 f
					clinton 	      73  90.55	 m	
	案例
			打开上面的文件，把记录读取出来.
	
	注意：
a.为什么在读取记录的第一个字段判定文件结束？
			只有从第一个字段，才知道记录是否存在。	
b.用什么格式写数据，就一定用什么格式读取数据。	c.创建文件时指定的权限与实际文件权限不匹配
			系统有权限屏蔽。
			umask 查看/设置屏蔽权限
			在程序可以使用umask函数设置屏蔽权限.
			mode_t umask(mode_t);


	
	4.文件定位（/proc/$pid/mem）
	
	
	5.IO与重定向
	
	
	6.文件描述符号的相关操作
	
	
	7.文件映射
	
	
	8.终端IO（Curses）


思考：
		使用umask函数修改权限屏蔽，是否影响终端中的权限屏蔽？
		umask对chmod有作用。
		
		1.使用open read close写一个与cat指令一样的程序显示文本文件。
		
		
		2.如下信息：
					ID0001  宽带  86.00  0  
					ID0002  固话		20.00  0.80
			写程序，把上面信息保存到文件。
					
		3.写一个程序，把上面产生的文件的内容全部读取出来。			
					
		4.打开/dev/tty文件，并且输出数据。
		
		
		5.整理上周与本周笔记，写readme.txt
		
					
