一.进程同步
	1.进程同步的背景
		进程通信的目的是交换数据，交换的数据分成两类：业务数据与保持进程同步的数据。
		
		在很多的情况下，需要保持进程同步：一个进程需要等待另外一个进程执行完毕，才执行。
		
		比如：
				两个进程完成孪生素数的查找。
						一个进程查找素数
						另外一个进程查找打印孪生素数。
		背景：
				进程之间需要协调运行：进程同步
	2.进程同步依赖的技术：进程数据通信
				2.1.回顾：进程通信技术
							a.基于文件
							b.基于内存
							c.信号
				
	3.进程同步编程
			3.1.使用信号实现同步
				a.僵尸回收
						父进程wait,子进程发送SIGCHLD信号,父进程wait结束
						等待->继续->[等待->继续]
				b.使用信号实现通用的进程同步【控制】
	案例：
			使用信号来同步素数的查找与孪生素数的查找。	
				
	结论：
			a.进程之间使用信号通信，最大的麻烦在于进程ID不确定。
				但父子进程确定。
					fork返回子进程的ID
					getpid得到自己的ID
					getppid()得到父进程的ID。
			b.关于信号对函数的影响
					sleep  pause		
					不可重入函数.sleep与pause被信号中断后，sleep与pause不会继续睡眠，而是马上返回。
					
			c.raise
					向当前进程发送信号		
			
			d.信号同步的缺陷：
					信号种类有限。
					怎样信号通知才能种类无限呢？
					
			3.2.使用信号量实现同步
					a.信号量是整数数组
					推荐使用信号量实现信号同步。
					原因：
						信号的种类有限
						信号其中必须考虑严肃的可重入的函数	
					b.信号量采用的共享内存
					
					c.信号量的主要作用不是交换数据，而是控制进程同步。
					
					d.编程模型
						
						A		B
						
				创建信号量			得到信号量 semget
				初始化信号量	semctl
				操作信号量继续			操作信号量等待 semop
				删除信号量	semctl
				
				
				函数说明：
						1.semget与msgget/shmget类似
						2.semctl与msgctl/shmctl类似
						3.semop
				int  semop(int semid,//信号量内存ID
				struct sembuf *semops,//定义对信号量的操作
				int ops);//指第二个参数的数组个数

				返回：0：成功
					-1：失败
	第二个参数的结构：定义操作						
		struct sembuf{
			unsigned short sem_num;//操作信号量的下标
			int sem_op;//对信号量操作方式
			int sem_flg;//信号量的操作标记，默认为0
		}	
		IPC_NOWAIT|SEM_UNDO（另外进程异常结束，信号量回滚到初始化状态[目的：防止死锁]）
		建议使用0或者SEM_UNDO
		
		
		信号量的操作方式：
				前提条件：信号量的值>=0
				
				+   直接向信号量加值,永远不会阻塞
				-   向信号量减值
						 判定是否够减
							     够减：减去信号量，返回
							     不够：阻塞，直到够减后，减去信号量，返回。
				0   主要目的是判定信号量是否为0
					        =0  semop返回
						 >0  semop阻塞，直到信号量为0
				
		使用方式
				A			B
				-减操作			0操作
				A			B
				+操作			-操作
案例：		
		A  					B
		每隔2秒让B进程执行			等待信号量再执行
				
二.Socket通信
		1.socket通信方式的模型。
				绑定的概念:
					先有一个socket描述符号
						
					再有物理通信载体
						
					把socket描述符号与物理通信载体绑定

		2.socket有两种基本模式。
				一对一的对等模式
				一对多的C(Client客户端)/S(Server服务器)模式：CS模型
		3.一对一的socket编程模式
				A					      	B
				建立socket描述符号				建立socket描述符号   socket
				绑定到socket文件				      sockaddr=物理载体    bind		
				从socket描述符号接收  recv			向指定的socket发送    send
				关闭socket描述符号				关闭描述符号           close
		函数的帮助文档浏览：
					int socket(
							int domain,//socket地址族（物理载体的类型）
									AF_UNIX		PF_UNIX
									AF_FILE		PF_FILE
									AF_LOCAL		PF_LOCAL
									
									AF_INET		PF_INET
									AF_RAW	
						    int type,//socket类型(产生描述的数据格式)
									SOCK_DGRAM（一对一）豹纹的格式
									SOCK_STREAM(一对多)流的格式
						    int protocol);//socket协议（数据含义：协议）
								大部分情况协议由第一个参数与第二个参数唯一确定，所以该参数大部分情况下为0
		
		返回值：-1:建立描述符号失败   否则：成功并返回描述符号
		这个返回值有三个参数条件决定。				

		通信地址
			struct sockaddr{};socket通信的通用格式
			不同通信载体采用不同的地址格式。
				UnixSocket文件通信：sockaddr_un
				Internet网络通信：sockaddr_in
			
		总结：
				地址结构体
				sockaddr_XX;
							

案例：
		一对一通信
			A
		1.建立socket
		2.构造通信地址					

作业：
		1.使用信号同步实现孪生素数查找。
			要求：
					子进程找素数。
					父进程找孪生素数。
		
		2.使用信号量实现孪生素数查找。


补充：
		回顾：
				1.make工具					
						make -f mk文件  目标
				2.文件名默认： GNUMakefile  
							  makefile  
							  Makefile		
				  目标默认：  第一个目标
				3.make脚本文件语法：
						3.1.#注释
						3.2.目标
						目标名:依赖目标
						\tab目标指令
						3.3.目标指令前可以使用@符号
				4.目标依赖
					4.1.案例：
								体会目标的依赖
					4.2.make依赖目标的规则
							使用make完成目标，make首先把目标当做文件名，判定当前路径是否有相同的文件，没有：直接执行
							有：比较该文件与依赖的目标对应文件的新旧。如果旧，则执行，如果新则提示“XX是最新的”
							注意：如果没有依赖目标，则目标对应文件就是最新的。
					4.3.建议对目标命名采用指令的结果作为目标名
					4.4.make有潜规则：
							如果依赖目标是.o文件
							make自动生成规则：
									xxx.o: xxx.c
										环境变量中GCC指定的编译器编译产生.o目标
					总结：
							a.建议使用结果文件名作为目标名
							b.目标不仅依赖，而且还要日期检测
							c.make会自动生成隐藏目标
					
					4.5.防止目标与文件歧义
								强制说明目标与文件没有关系
							伪目标
							声明伪目标：
							.PHONY:伪目标名1   伪目标名2 ...
						
										
