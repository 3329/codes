一.理解信号
	1.信号是一个整数，表达的是一种信息
		kill -l
		
		这些信号（信息）影响操作系统的行为（如果没有注册）
	案例：
			体会SIGWINCH,SIGINT信号对系统的影响
			
	案例总结：
			用户按下ctrl+c，
			系统接收到这个键盘的硬件操作		
			系统发送信号给进程(用户发送信号)
			系统判定进程是否注册该信号。
			如果注册，则调用该信号的注册函数。
			如果没有注册，则系统自动进行默认处理。
			
			大部分的信号系统处理的时候：
						打印信号信息，然后结束进程。
						直接结束进程
						什么都不处理
						导出一个内核导出文件core,然后结束进程
		总结：
				信号发出：
						1.硬件发出信号
						2.系统发出信号
						3.用户在程序中发出信号
						4.用户在终端中使用shell指令发出信号
	2.使用kill发送信号
			kill -s 信号 进程ID
			
			信号格式：
						整数,比如:2
						宏,比如:SIGINT
						简单宏,比如:INT
						硬件操作,比如ctrl+c
						
	3.理解信号处理==中断
				进程如果注册信号，则当进程接收信号的时候，系统暂停进程的执行，并执行信号处理函数，函数执行完毕，继续回到原进程代码执行。（模拟软中断）
	4.理解信号的分类
			不可靠信号/非实时信号
				01-31信号：会被系统压缩/合并 
			可靠信号/实时信号
				34-64信号：不会被系统压缩/合并
			
			信号为什么分类：
				早期信号1-31，都是对系统有特定含义的。
				系统处理信号有特点：
						比如关机信号：多次关机信号只有一次执行的必要，从而早期信号有自动压缩的设计理念。
				早期信号专门留出两个信号10 12给用户使用。但用户希望信号不被压缩。
				
				系统设计重新设计34-64的信号。称为可靠信号。		
			
      二.信号的处理与发送信号
	1.信号处理
		signal函数说明:
			sighandler_t signal(int sig,//注册信号
				sighandler_t handle);//信号的处理函数
			
			返回值:
					上次注册的信号处理函数。
		结论：
				一个信号只能注册一个信号处理函数.
				但一个函数可以作为多个信号的处理函数.
		
		注意：
				1.有两个信号不能注册，只能由系统处理。
				SIGKILL	SIGSTOP
				2.系统提供的两个处理函数。
							SIG_DFL（缺省处理） -1
							SIG_IGN（信号忽略） 0
				
	2.信号的发送
				int kill(pid_t pid,int sig);
				返回值：
						0:OK
						-1:FAIL
				参数1：
						pid_t pid，发送信号的目标进程ID
							>0  进程ID
							=0	发送给当前进程所在进程组的所有进程
							-1	发送给所有进程
							<-1 发送给进程组ID=|pid|的所有进程
		案例：
				写两个程序，一个处理信号
										一个发送信号
				体会信号的可靠与不可靠
				
	3.定时器信号			
		SIGALRM
		3.1.alarm函数(延时器)
				函数说明
				unsigned int alarm(unsigned int sec);
				作用：
						告诉操作系统在sec秒的后，发送一个
							SIGALRM信号给当前进程。
				注意：
						只发送一次，不是反复发送。
				
				返回：
						返回上次定时器剩余的时间。
											
				案例：
						
		3.2.setitimer(定时器)
				int setitimer(
						int whence,/*时间计算方法*/
						const struct itimerval *val,/*定时器时间设置*/
						struct itimerval *oldval);/*上次定时器设置时间,使用NULL表示不返回*/
						
				
				返回：
						0：成功
						-1：失败		
		
				时间计算方法：
						ITIMER_REAL：真实时间
						ITIMER_VIRTUAL：进程实际消耗时间
						ITIMER_PROF:混合计算	
				struct itimerval
				{
					struct timeval it_interval;//间隔时间
					struct timeval it_value; //延时时间
				}
				struct timeval
				{
				long tv_sec;    秒
				long tv_usec;   微秒
				}
				
				延时时间不能是0。
				
			在延时时间后，每隔间隔时间，系统会发送一次信号。
			案例：
					使用定期器+进程实现7位随机数与时间同时显示.
			程序结构：
					1.建立定时器信号结构			
					2.初始化Curses
					3.显示7位随机数
					4.显示时间
					
														
	4.信号的屏蔽及其相关操作
		4.1.什么是信号屏蔽，信号什么时候需要屏蔽
				信号屏蔽：在某段代码执行的时候，代码执行不被信号中断。
				功能：
						保护某段代码不受信号的中断。
		4.2.信号集
				sigset_t
				信号集的数据操作:
							清空所有信号sigemptyset
							填充所有信号sigfillset
							添加信号sigaddset
							删除信号sigdelset
							判定某个信号在信号集中	
										sigismember
		4.3.sigprocmask函数说明
				int sigprocmask(
					int how,//信号操作方式
					const sigset_t *sigs,//操作的信号集合
					sigset_t *oldsig);//返回上次信号集合
			
			SIG_BLOCK
			SIG_UNBLOCK
			SIG_SETMASK
			
			注意：
					屏蔽信号不会被丢弃，而是存放队列中排队。等待信号屏蔽接触后，系统发送给进程。
		4.4.sigpending
				返回已经发生但被屏蔽的信号。
				
				int sigpending(sigset *sigs);
				可以通过查询某个信号，控制中断点
		4.5.sigsuspend
				int sigsuspend(const sigset_t *sigs);
				
				解除原来的屏蔽信号，开始新的信号屏蔽
				如果没有信号发生，则函数阻塞。
				当信号发生，sigsuspend返回，返回前解除新的信号屏蔽，回复原来的信号屏蔽。
			功能：
					新旧屏蔽信号之间原子切换。
					挂起功能：没有信号发生，会一直阻塞。
												
		
							
	5.高级信号发送与处理
			
	
三.信号的应用
		1.信号实现同步
		2.进程间的通信 
		3.简单的多任务

作业：
		1.显示7位随机数，按键控制继续/暂停
				要求：定时器信号
				要求处理ctrl+c终止程序
				提示：7位随机数使用定时器。
							按键在主进程中处理。	
							
		2.在上面程序中添加信号保护。
				7位随机数在产生，显示的时候不被任何信号干扰。
				
				
				
